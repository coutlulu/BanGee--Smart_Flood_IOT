# BanGee- Smart_Flood_IOT

ðŸŒŠ BanGee Flood Defense System (IoT)
Version: 1.0.0 Architecture: 5-Layer IoT Model (Perception, Network, Processing, Application, Business) Tech Stack: ESP32, Google Cloud Platform (VM), AWS Lightsail, Supabase (PostgreSQL), Next.js, MQTT (Mosquitto).

ðŸ“‹ Table of Contents
System Architecture
Prerequisites
Layer 3: Processing (Database Setup)
Layer 2: Network & Middleware (GCP Setup)
Layer 1: Perception (ESP32 Hardware)
Layer 4: Application (AWS Dashboard)
Layer 5: Business (Analysis)
Troubleshooting

1. System Architecture
The system follows a strict 5-Layer IoT architecture:
Perception: ESP32 reads Water Levels/Flow and controls Valves/Pumps.
Network: GCP VM hosts the Mosquitto MQTT Broker and the Bridge Script.
Processing: Supabase stores historical logs and manages the command queue.
Application: AWS Lightsail hosts the Next.js Real-time Dashboard.
Business: Data analysis for flood prediction and asset protection.

2. Prerequisites
Hardware: ESP32 Dev Kit V1, Ultrasonic Sensors (x3), Flow Sensors (x2), Servos (x2), Relay Module, 12V Pump, Buzzer, RGB LED.
Cloud Accounts: Google Cloud Platform (GCP), AWS, Supabase.
Software: Arduino IDE, PuTTY (or Terminal), Node.js (v20+).

3. Layer 3: Processing (Database Setup)
We start here to get API Keys needed for other layers.
Create Project:
Go to Supabase.
New Project -> Name: BanGee-DB -> Region: Singapore.
Save your credentials: Go to Project Settings > API. Copy the Project URL and anon / public Key.
Create Tables (SQL Schema):
Go to the SQL Editor in Supabase.
Run the following query:
SQL
-- Table for Sensor Logs
create table flood_logs (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  river_level int,
  tank1_level int,
  tank2_level int,
  flow_rate1 float,
  flow_rate2 float,
  rain_status text,
  status text,
  valve1_state int,
  valve2_state int,
  buzzer_state boolean,
  led_color text
);

-- Table for Admin Commands (Manual Button)
create table command_queue (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  command_type text
);


4. Layer 2: Network & Middleware (GCP Setup)
Hosts the MQTT Broker and the Bridge Script.
A. VM Creation
GCP Console > Compute Engine > Create Instance.
Name: bangee-broker.
Region: asia-southeast1 (Singapore).
Machine: e2-micro.
OS: Ubuntu 22.04 LTS.
Firewall: Allow HTTP/HTTPS. Create.
B. Network Configuration (Firewall Rule)
CRITICAL STEP: GCP blocks port 1883 by default.
Go to VPC Network > Firewall.
Click Create Firewall Rule.
Name: allow-mqtt-1883.
Targets: All instances in the network.
Source IPv4: 0.0.0.0/0.
Protocols/Ports: TCP 1883.
C. Install MQTT Broker (Mosquitto)
SSH into the VM and run:
Bash
sudo apt update
sudo apt install mosquitto mosquitto-clients -y

Configure External Access:
Bash
sudo nano /etc/mosquitto/mosquitto.conf

Scroll to the bottom and paste:
Plaintext
listener 1883
allow_anonymous true

Save (Ctrl+X, Y, Enter) and restart:
Bash
sudo systemctl restart mosquitto

Note the External IP of this VM. This is your MQTT Server IP.
D. Setup Middleware (Bridge Script)
1. Install Node.js v20 (Latest):
Bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
source ~/.bashrc
nvm install 20
node -v  # Verify it says v20.x.x

2. Install PM2 & Dependencies:
Bash
sudo npm install -g pm2
mkdir ~/bangee-bridge && cd ~/bangee-bridge
npm init -y
npm install mqtt @supabase/supabase-js dotenv

3. Create Files:
nano .env:
Code snippet
SUPABASE_URL=your_supabase_url_here
SUPABASE_KEY=your_supabase_anon_key_here


nano bridge.js: (Paste the bridge.js code provided in project documentation).
4. Start Bridge:
Bash
pm2 start bridge.js --name "mqtt-bridge"
pm2 save
pm2 startup


5. Layer 1: Perception (ESP32 Hardware)
A. Wiring Diagram
River Sensor (Ultra): Pin 34 (Echo), Trig shared.
Tank 1 Sensor (Ultra): Pin 36 (Echo).
Tank 2 Sensor (Ultra): Pin 39 (Echo).
Rain Sensor: Pin 35 (Analog).
Flow Sensors: Pin 27 (Drain 1), Pin 14 (Drain 2).
Servos: Pin 18 (Valve 1), Pin 19 (Valve 2).
Pump Relay: Pin 23.
Buzzer: Pin 4.
RGB LED: 21 (R), 22 (G), 5 (B).
B. Firmware Setup
Arduino IDE Libraries: Install ESP32Servo, PubSubClient, WiFi.
Configuration:
C++
const char* ssid = "Your_WiFi_Name";
const char* password = "Your_WiFi_Password";
const char* mqtt_server = "EXTERNAL_IP_OF_GCP_VM"; 


Upload Code: Use the finalized code with 100ms sampling rate.

6. Layer 4: Application (AWS Dashboard)
A. VM Creation (Lightsail)
AWS Lightsail > Create Instance.
Platform: Linux/Unix > Node.js Blueprint.
Region: Singapore.
Plan: $5 USD.
B. Network Configuration (Firewall)
Click Instance > Networking.
IPv4 Firewall > Add Rule.
Protocol: TCP, Port: 3000.
C. Server Setup (Root Access)
SSH into the instance:
Bash
sudo su
cd /home/bitnami

Update Node.js (Critical - Blueprints are often old):
Bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
nvm install 20
nvm alias default 20
npm install -g pm2

D. Application Installation
Create Project:
Bash
npx create-next-app@latest dashboard
# Select: No TypeScript, Yes ESLint, Yes Tailwind, Yes src/, Yes App Router.


Install Dependencies:
Bash
cd dashboard
npm install @supabase/supabase-js recharts lucide-react dotenv


Project Files:
nano .env.local: Add NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY.
nano src/app/page.js: Paste final Dashboard Code (Ensure maxLevel matches your sensor calibration).
nano src/app/globals.css: Add custom animations.
E. Deployment
Bash
npm run build
pm2 start npm --name "flood-dashboard" -- start
pm2 save

Access via: http://YOUR_AWS_IP:3000

7. Layer 5: Business (Analysis)
Real-time Monitoring: View live water levels to prevent overflow.
Maintenance: Monitor flow_rate. Low flow with open valves = Clog/Maintenance required.
Safety: Automated alerts (Siren/LED) protect on-site personnel.

